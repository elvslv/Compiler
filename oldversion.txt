#include "scanner.h"
#include <iostream>
#include <algorithm>
#include <list>

void Scanner::gc()
{
	if (!File.eof())
		File.get(curCh);
}

void Scanner::SkipDelimeters()
{
	gc();
	while (!File.eof() && (curCh == '\n' || curCh == '\t' || curCh == ' ')) // \0
	{
		if (curCh == '\n')
		{
			pos = 0;
			++curLine;
		}
		else
			++pos; //?????
		gc();
	}
}

void Scanner::ChangePosIndex()
{
	if (curCh == '\n' && !File.eof())
	{
		++curLine;
		pos = 0;
	}
	else
		++pos;
}

void Scanner::CatchLexError(LexicalError lx)
{
	LexicalError error(lx.GetText(), lx.GetErrorPos(), lx.GetErrorLine()); 
	fndErr = true;
	curToken.~Token();
	curToken = BadToken();
}

void Scanner::SkipComments()
{
	try
	{
		bool f = true;
		while (curCh == '/' && f || curCh == '{' || curCh == '(')
		{
			if (curCh == '/')
			{
				gc();
				if (curCh == '/')
				{
					for (; !File.eof() && curCh != '\n'; File.get(curCh));
					if (File.eof())    
					{
						curToken.~Token();
						curToken = EndOfFile();
						return;
					}
					else
					{
						pos = 0;
						++curLine;
						SkipDelimeters();
					}
				}
				else
				{
					CurChPutBack('/');
					f = false;
				}
			}
			else
				if (curCh == '{')  
				{
					for ( ;!File.eof() && curCh != '}'; File.get(curCh), ChangePosIndex());
					if (File.eof())
						throw LexicalError("Unclosed comment", pos, curLine);
					SkipDelimeters();
				}
				else
				{
					if (curCh == '(')
					{
						if (!File.eof())
						{
							File.get(curCh);
							ChangePosIndex();
							if (curCh == '*')
							{
								do
								{
									gc();
									ChangePosIndex();
									for (; !File.eof() && curCh != '*'; File.get(curCh), ChangePosIndex());
									if (curCh == '*')
									{
										gc();
										if (File.eof())
											throw LexicalError("Unclosed comment", pos, curLine);
										else
											if (curCh == ')')
											{
												gc();
												ChangePosIndex();
												break;
											}
										ChangePosIndex();
									}
									else
										if (File.eof())
											throw LexicalError("Unclosed comment", pos, curLine);
								} while (true);
							}
						}
						else
							throw LexicalError("Unclosed comment", pos, curLine);
					}
				}
		}
	}
	catch(LexicalError lx)
	{
		CatchLexError(lx);
		return;
	}
}

bool IsAlpha(char ch)
{
	return ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z';
}

bool IsDigit(char ch)
{
	return ch >= '0' && ch <= '9';
}

void Scanner::CurChPutBack(char ch)
{
	File.putback(curCh);
	curCh = ch;
}

void Scanner::Next()
{	
	try
	{
		bool f = true;
		if (curToken.GetType() == ttEOF || curToken.GetType() == ttBadToken)
			return;
		//SkipDelimeters();
		if (File.eof())
		{
			curToken.~Token();
			curToken = EndOfFile();
			return;
		}
		//SkipComments();
		curPos = pos;
		char* tmp = "";
		gc();
		tmp = tmp + curCh;
		if (curCh == '\'')   //string or char literal
		{
			while (!File.eof())
			{
				File.get(curCh);
				if (curCh == '\n' || File.eof())
					break;
				++pos;
				tmp += curCh;
				int cnt = 0;
				for ( ;curCh == '\'' && !File.eof(); tmp += curCh, ++cnt, File.get(curCh));
				pos += cnt;
				if (cnt % 2) 
				{
					--pos;
					CurChPutBack('\'');
					curToken.~Token();
					if (strlen(tmp) > 3)
						curToken = SymbLiteral(curPos, curLine, tmp);
					else
						curToken = StringLiteral(curPos, curLine, tmp);
					curPos = pos;
					return;
				}
			}
			if (strlen(tmp) > 2)
				throw LexicalError("Wrong string literal", curPos, curLine);
			else
				throw LexicalError("Wrong string or char literal", curPos, curLine);
			return;
		}
		if (IsDigit(curCh))  //Integer or Real Literal
		{
			bool fComma = false;
			bool fExp = false;
			bool fSign = false;
			bool fError = false;
			int expPos = -1;
			gc();
			while (!File.eof() && (IsDigit(curCh) || curCh == 'e' || curCh == 'E' || curCh == '.' || 
					curCh == '-' || curCh == '+'))
			{
				if (curCh == 'e' || curCh == 'E')
				{
					if (fExp)
						fError = true;
					fExp = true;
					expPos = pos + 1;
				}
				if (curCh == '.')
				{
					if (fExp || fComma)
						fError = true;
					fComma = true;
				}
				if (curCh == '-' || curCh == '+')
				{
					if (fSign && pos == expPos + 1) //two signs next
						fError = true;
					if (fExp && expPos != pos || !fExp)   //binary operation
					{
						CurChPutBack(tmp[strlen(tmp) - 1]);
						curToken.~Token();
						if (fExp || fComma)
							curToken = RealLiteral(curPos, curLine, tmp);
						else
							curToken = IntLiteral(curPos, curLine, tmp);
						curPos = pos;
						return;
					}
					fSign = true;
				}
				if (fError)
					throw LexicalError("Wrong integer or real literal", curPos, curLine);
				else
				{
					++pos;
					tmp += curCh;
					gc();
				}
			}
			char* t = "";
			t += curCh;
			TokenType type = TT.find(t)->second;
			char tch = tmp[strlen(tmp) - 1];
			if (type != ttDelimiter || type != ttSeparator || type != ttOperation || !(tch >= '0' || tch <= '9'))
				throw LexicalError("Wrong integer or real literal", curPos, curLine);
			CurChPutBack(tch);
			curToken.~Token();
			if (fExp || fComma)
				curToken = RealLiteral(curPos, curLine, tmp);
			else
				curToken = IntLiteral(curPos, curLine, tmp);
			curPos = pos;
			return;
		}
		if (IsAlpha(curCh)) //Identifier
		{
			gc();
			for ( ;!File.eof() && (IsAlpha(curCh) || IsDigit(curCh)); ChangePosIndex(), tmp += curCh, gc());
			if (!File.eof())
				CurChPutBack(tmp[strlen(tmp) - 1]);
			curToken.~Token();
			if (TT.find(tmp) -> second == ttKeyWord)
				curToken = KeyWord(curPos, curLine, tmp);
			else
				curToken = Identifier(curPos, curLine, tmp);
			curPos = pos;
			return;
		}
		if (TT.find(tmp)->second == ttSeparator) 
		{
			if (curCh == ':')
			{
				gc();
				if (curCh == '=')
				{
					curToken.~Token();
					curToken = Operation(curPos, curLine, ":=");
					++curPos;
					return;
				}
				else
					CurChPutBack(':');
			}
			curToken.~Token();
			curToken = Separator(curPos, curLine, tmp);
			return;
		}
		if (TT.find(tmp)->second == ttOperation) 
		{
			if (curCh == '>' || curCh == '<')
			{
				char t = curCh;
				gc();
				if (curCh == '=' || t == '<' && curCh == '>')
				{
					curToken.~Token();
					tmp += curCh;
					curToken = Operation(curPos, curLine, tmp);
					++curPos;
					return;
				}
				else
					CurChPutBack(t);
			}
			else
			{
				curToken.~Token();
				curToken = Operation(curPos, curLine, tmp);
				return;
			}
		}
	}
	catch(LexicalError lx)
	{
		CatchLexError(lx);
		return;
	}
}

void Scanner::FillTokenTypes()
{
	TT["ABS"] = ttKeyWord;
	TT["AND"] = ttKeyWord;
	TT["ARRAY"] = ttKeyWord;
	TT["BEGIN"] = ttKeyWord;
	TT["CASE"] = ttKeyWord;
	TT["CONST"] = ttKeyWord;
	TT["DIV"] = ttKeyWord;
	TT["DO"] = ttKeyWord;
	TT["DOWNTO"] = ttKeyWord;
	TT["ELSE"] = ttKeyWord;
	TT["END"] = ttKeyWord;
	TT["FOR"] = ttKeyWord;
	TT["FUNCTION"] = ttKeyWord;
	TT["FORWARD"] = ttKeyWord;
	TT["GOTO"] = ttKeyWord;
	TT["IF"] = ttKeyWord;
	TT["IN"] = ttKeyWord;
	TT["MOD"] = ttKeyWord;
	TT["NIL"] = ttKeyWord;
	TT["NOT"] = ttKeyWord;
	TT["OF"] = ttKeyWord;
	TT["OR"] = ttKeyWord;
	TT["PROCEDURE"] = ttKeyWord;
	TT["PROGRAM"] = ttKeyWord;
	TT["RECORD"] = ttKeyWord;
	TT["REPEAT"] = ttKeyWord;
	TT["SET"] = ttKeyWord;
	TT["SHL"] = ttKeyWord;
	TT["SHR"] = ttKeyWord;
	TT["STRING"] = ttKeyWord;
	TT["THEN"] = ttKeyWord;
	TT["TO"] = ttKeyWord;
	TT["TYPE"] = ttKeyWord;
	TT["UNTIL"] = ttKeyWord;
	TT["USES"] = ttKeyWord;
	TT["VAR"] = ttKeyWord;
	TT["WHILE"] = ttKeyWord;
	TT["WITH"] = ttKeyWord;
	TT["XOR"] = ttKeyWord;
	TT["READLN"] = ttKeyWord;
	TT["WRITELN"] = ttKeyWord;
	TT["INTEGER"] = ttKeyWord;
	TT["BYTE"] = ttKeyWord;
	TT["SHORTINT"] = ttKeyWord;
	TT["WORD"] = ttKeyWord;
	TT["LONGINT"] = ttKeyWord;
	TT["INT64"] = ttKeyWord;
	TT["BOOLEAN"] = ttKeyWord;
	TT["CHAR"] = ttKeyWord;
	TT["SINGLE"] = ttKeyWord;
	TT["REAL"] = ttKeyWord;
	TT["DOUBLE"] = ttKeyWord;
	TT["EXTENDED"] = ttKeyWord;
	TT["COMP"] = ttKeyWord;
	TT["."] = ttSeparator;
	TT[","] = ttSeparator;
	TT["("] = ttSeparator;
	TT[")"] = ttSeparator;
	TT["["] = ttSeparator;
	TT["]"] = ttSeparator;
	TT["{"] = ttSeparator;
	TT["}"] = ttSeparator;
	TT[";"] = ttSeparator;
	TT[":"] = ttSeparator;
	TT["+"] = ttOperation;
	TT["-"] = ttOperation;
	TT["/"] = ttOperation;
	TT["*"] = ttOperation;
	TT["="] = ttOperation;
	TT[">"] = ttOperation;
	TT["<"] = ttOperation;
	TT["<>"] = ttOperation;
	TT[":="] = ttOperation;
	TT[">="] = ttOperation;
	TT["<="] = ttOperation;
	TT[" "] = ttDelimiter;
	TT["\n"] = ttDelimiter;
	TT["\t"] = ttDelimiter;
}
